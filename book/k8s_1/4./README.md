

  - 오케스트레이션의 기본 단위는 파드
  - 파드는 컨테이너로 이루어져 있다.

  - 파드들은 워커 노드라는 노드 단위로 관리. 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터가 됌. 파드는 1개 이상의 컨테이너로 이루어짐.,
  - 파드는 쿠버네티스로 부터 IP를 받아 컨테이너가 외부로 통신할 수 있는 경로 제공. 컨테이너들이 정상적으로 작동하는지 확인, 네트워크, 저장 공간 공유.
  - 컨테이너를 돌보는 것이 파드, 파드를 돌보는 것이 쿠버네티스 워커노드, 워커 노드를 돌보는 것이 쿠버네티스 마스터. (쿠버네티스 마스터 도 파드로 이루어짐)

  - 컨테이너 : 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간. (개별적 실행 환경 : CPU, 네티워크, 메모리 자원을 독자적으로 사용하도록 할당된 환경)
  - 개별적 실행 환경에서 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리. 각 컨테이너에서 실행되는 앱은 서로 영향을 미치지 않음.

  - 컨테이너 관리도구: 컨테이너디, 크라이오, 카타 컨테이너, 도커 등등..

  - 도커 학습 과정 : 이미지 찾기 -> 실행하기 -> 디렉터리와 연결하기 -> 삭제하기
  - 컨테이너 이미지는 도커와 같은 CRI로 불러들여야 컨테이너가 실제로 작동. 컨테이너 삭제시 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야 디스크의 용량을 확보한다.
  
  - docker search [...]  (이미지 검색)
  + index : 이미지가 저장된 레지스트리 이름
  + name : 검색된 이미지 이름.공식 이미지를 제외한 나머지는 "레지스트리 주소/저장소 소유자/ 이름" 형태.
  + description : 이미지에 대한 설명
  + stars : 해당 이미지를 내려받은 사용자 평가.
  + official : ok 표시는 해당 이미지에 포함된 앱, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지라는 뜻.
  + automated : ok 표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지.

  - docker pull [...] (이미지 내려받기)
  + 태그(tag) : Using default tag와 함꼐 뒤 따라오는 태그 이름을 통해 이미지를 내려받을때 사용한 태그를 알 수 있음. 아무조건 없이 pull시 latest 태그 적용.
  + 레이어(layer) : 하나의 이미지는 여러 개의 레이어로 이루어져 있어 레이어마다 pull complete 메세지 발생.
  + 다이제스트(digest) : 이미지의 고유 식별자. 이미지에 포함된 내용과 이미지 생성환경을 식별 가능. 해시함수로 생성되 이미지가 동일한지 검증하는데 사용. (이름, 태그는 임의로 지정해 동일한지 비교 불가능)
  + 상태(status) : 이미지를 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있다. 형식 "레지스트리 이름/이미지 이름:태그"


  - 이미지 태그 
  + 태그: 이름이 동일한 이미지에 추가하는 식별자. 이름이 동일해도 도커 이미지의 버전이나 플랙폼이 다를 수 있기때문에 이를 구분하는데 사용.
  + 태그 명시 하지 않으면 latest 태그를 기본으로 사용.

  - 이미지 레이어 구조
  + docker images [...] (내려받은 이미지 조회)
  + docker history [...] (생성과정에서 단계별로 용량을 얼마나 차지하는지 이력 조회)
  + 컨테이너 이미지는 각종 앱 파일을 담고 있어 압축 파일에 가까움.
  + 이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유해 전체 용량을 감소시킴.

  - 컨테이너 실행
  + docker run -d --restasrt always [...] (새로운 컨테이너 실행) { docker run [옵션] <사용할 이미지 이름>[:태그 | @다이제스트]
  + -d(--detach) : 컨테이너를 백그라운드에서 구동한다는 의미. 생략시 컨테이너 내부에서 실행되는 앱의 상태가 화면에 계속 표시. 여기서 ctrl + c시 앱뿐 아니라 컨테이너도 함께 중단. 따라서 계속 작동해야 하는 서버나 db는 -d 옵션을 붙여야 한다.
  + --restart always : 컨테이너의 재시작과 관련된 정책을 의미하는 옵션. 프로그램에 예상하지 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우에 컨테이너도 작동이 중지됌. 이때 중지된 컨테이너를 즉시 재시작하거나 리눅스 시스템에서 도커 서비스가 작동할 떄 컨테이너를 자동으로 시작하도록 설정할 수 있다.

  + docker ps (컨테이너 상태 확인)
  + container id : 컨테이너를 식별하기 위한 고유 ID. docker run를 실행한 결과 일부가 표시.
  + iamge : 컨테이너를 만드는 데 사용한 이미지.
  + command : 컨테이너 생성시 내부에서 작동할 프로그램을 실행하는 명령어.
  + created : 컨테이너가 생성된 시각.
  + status : 컨테이너가 작동을 시작한 시각을 표기. created와 달리 재시작시 초기화.
  + ports : 컨테이너가 사용하는 포트와 프로토콜을 표시.
  + names ; 컨테이너의 이름 표시 (docker run --name <이름>) 지정 가능. 지정하지 않으면 컨테이너가 시작될 떄 임의로 부여함.

  - 요청에 따른 응답을 컨테이너에서 받아줄 수 있게 포트 연결 설정이 추가로 필요함.
  - docker run -d -p 8080:80 --name nginx-exposed --restart always nginx

  - 도커는 컨테이너 내부에서 컨테이너 외부의 파일을 사용할수 있는 방법 4개를 가짐 
    
    1. docker cp : docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로> 형식으로 호스트에 위치한 파일을 구동중인 컨테이너 내부에 복사. 컨테이너 내부 저장된 설정, 로그 추출 확인 목적으로도 사용.
    2. Dockerfile ADD : 이미지는 Dockerfile 기반으로 만들어짐. ADD구문으로 컨테이너 내부로 복사할 파일 지정시 이미지 빌드할때 지정 파일이 이미지 내부로 복사됨.
    3. 바인드 마운트 : 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법. 새 컨테이너 구동시 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있다. db데이터 디렉터리나 서버 첨부파일 디렉터리 처럼 컨테이너가 바뀌어도 없어지면 안되는 자료는 이방법으로 보존.
    4. 볼륨 : 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결. 쿠버네티스의 볼륨 구조와 유사한 볼륨이다.


  - docker 정지
  + docker stop [컨테이너 이름]
  + docker stop [컨테이너 id (4자)]

  - docker 삭제 (위랑 비슷)
  + docker rm ....

  - 컨테이너, 이미지 삭제는 따로다 위 rm은 컨테이너만 삭제된다
  - docker rmi $(docker images -q [nginx]


  - 컨테이너 이미지 만드는 방법.
   1. 기본 방법으로 빌드
```
  자바 소스 빌드 -> 도커파일 작성 -> 도커파일 빌드 -> 빌드 완료
```
   2. 컨테이너 내부에서 컨테이너 빌드
```
  도커 파일 작성 -> 도커 파일 빌드 -> 빌드 완료
```
   3. 최적화 해 컨테이너 


