
## 15. 클래스와 멤버의 접근 권한을 최소화하라
  
  - 컴포넌트 설계의 가장 큰 차이는 내부 데이터, 구현정보를 잘 숨기는것.
  - 정보은닉의 장점.
```
  1. 개발 속도를 높임. 여러 컴포넌트를 병력로 개발 하기 때문.
  2. 관리 비용을 낮춤. 각 컴포넌트 파악이 빨라지고 디버깅, 교체 부담이 적어짐.
  3. 특정 컴포넌트 최적화를 통해 다른 컴포넌트 영향을 주지 않고 최적화 가능.
  4. 독립적인 컴포넌트라면 재사용성이 올라감.
  5. 큰 시스템을 제작하는 난이도를 낮춰줌.
```
  - 가장 바깥 클래스(톱 레벨 클래스), 인터페이스에 부여할 수 잇는 접근 수준은 package-private(default), public.
  - public클래스는 패키지의 api, package-private는 내부 구현에 속함.
  - 모든 멤버는 기본적으로 private. 이후 접근이 필요한 것들에멘 권한을 풀어준다.
  - 권한을 풀어주는일이 많아지면, 컴포넌트 분해를 생각해보자.
  - 테스트 목적은 접근 범위를 적당히 넓혀도 됨. (public 클래스의 private멤버를 package-private까지 푸는것)
  - 일반적으로 public 가변 필드는 thread-safe하지 않음.
  - 클래스에서 public static final 배열 필드를 두거나, 이 필드를 반환하는 메서드는 제공하면 안된다. (제공시 해결책은 2가지)
```java
  public static final Thing[] VALUES= { ... };
  
  1. private로 만들고 public 불변 리스트 추가.
  private static final Thing[] PRIVATE_VALUES = { ... };
  pulic static final List<Thing> VALUES = 
      Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
      
  2. 배열을 private로 만들고 복사본 반환하는 public메서드 추가(방어적 복사)
  private static final Thing[] PRIVATE_VALUES = { ... };
  public static final Thing[] values() {
      return PRIVATE_VALUES.clone();
  }
```

## 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
  
  - 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공해라.
  - package-private or private 중첩 클래스라면 데이터 필드를 가끔 노출하는게 나을떄도 있다.

## 17. 변경 가능성을 최소화하라

  - 자바 불변 클래스들은 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 달라지지 않음.(String, 기본타입 박싱 클래스, BigInterger, BigDecimal)
  - 클래스를 불변으로 만드는 5가지 규칙
```
  1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  2. 클래스를 확장할 수 없게 한다.
    1) final
    2) 모든 생성자를 private or package-private로 만들고 public 정적 팩터리 제공.
  3. 모든 필드를 final로 선언한다.
  4. 모든 필드를 private로 선언한다.
  5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
```
  - 불변 객체는 근본적으로 스레드 안전, 동기화 할 필요가 없다.
  - 불변 클래스는 자주 사용되는 인스턴스를 캐싱해 중복 생성 막는 정적 팩터리 제공 가능.
  - 불변 클래스는 clone 메서드, 복사 생성자를 막는게 좋다.
  - 불변 객체는 공유가 쉽고, 불변 객체끼리 내부데이터 공유가 가능.
  - 불변 객체는 그 자체로 실패 원자성을 제공.
  - 불변으로 만들 수 없는 클래스 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
  - 단점은 값이 다르면 반드시 독립된 객체로 만들어야 한다.
  - 크기에 따라 불변객체 특정 연산은 시간,공간을 많이 잡아먹음
```
  함수형 프로그래밍 : 피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴
  절차형, 명령형 프로그래밍 : 반대로 피연사자인 자신을 수정해 자신의 상태가 변하게 됨.
  
  불변 객체 단점 해소 방안
  다단계 연산들을 예측하여 기본기능으로 제공한다.
    ex) BigInteger <-> companion class,      String <-> StringBuilder    
```

## 18. 상속보다는 컴포지션을 사용하라

  - 상속은 잘못 사용하면 오류를 내기 쉽다.
  - 클래스가 인터페이스 구현, 인터페이스가 다른 인터페이스 확장은 다른 이야기
  - 상위 클래스 구현이 하위 클래스 동작에 이상을 줄 수 있음.
  - 상위 클래스의 메서드 수정, 구현 변수 추가등.. 여러가지 변수가 너무 많다.
  - 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조하게 하자. (컴포지션), 전달 클래스도 같이 사용.

## 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
  - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
  - Implementation Requirements 시작 절은 그 메서드의 내부 동작 방식을 설명하는 곳. 이곳에 @implSpec 태그를 달면 자바독 도구가 생성해줌.
  - @impleSpec 태그 활성화는 명령줄 매개변수로 -tag "implSpec:a:Implementation Requirements:" 를 지정해줘야 함.
  - 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할수도 있다.
  - 상속용으로 설계한 클래스는 배포 전에 하위클래스를 만들어 검증해야 함.
  - 상속용 클래스의 생성자, clone, readObject는 직,간접적으로든 재정의 가능 메서드를 호출해서는 안됨.

## 20. 추상 클래스보다는 인터페이스를 우선하라

  - 자바 제공 다중 구현 메커니즘 : 인터페이ㅅ, 추상 클래스.
  - 자바 8부터 인터페이스도 디폴트 메서드 제공. (두개다 인스턴스 메서드 구현 형태로 제공 가능)
  - 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다. (믹스인: 클래스가 구현할 수 있는 타입)
  - 인터페이스와 골격 구현 클래스를 이용하는 방법도 있다.

## 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

  - 자바8 부터 인터페이스에 메서드를 추가하게 디폴트 메서드 가능.
  - but 디폴트 메소드 추가시 재정의하지 않은 모든 클래스는 디폴트 구현이 쓰임.
  - 또한 디폴트 메소드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.

## 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

  - 
## 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
## 24. 멤버 클래스는 되도록 static으로 만들라
## 25. 톱레벨 클래스는 한 파일에 하나만 담으라
