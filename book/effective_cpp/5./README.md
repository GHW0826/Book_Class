
## 26. 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자
  
  - 생성자, 소멸자가 있는 변수 사용시, 생성자, 소멸자의 비용이 들기 때문에 사용하기 바로 전에 선언하자.
```cpp
  // 1. 생성자 1번, 소멸자 1번, 대입 n번
  TEST t;
  for (int i = 0; i < n; ++i)
    t = i;
  
  // 2. 생성자 n번, 소멸자 n번
  for (int i = 0; i < n; ++i)
    TEST t(i);
```

## 27. 캐스팅은 절약, 또 절약! 잊지 말자

  - 캐스트 방식 (C 스타일)
    1. (T) 표현식 // 표현식 부분을 T 타입으로 캐스팅
    2. T (표현식) // 표현식 부분을 T 타입으로 캐스팅
  
  - 캐스트 방식 (C++)
    1. const_cast<T>(표현식) : 객체의 상수성을 없애는 용도로 사용.
    2. dynamic_cast<T>(표현식) : 안전한 다운캐스팅을 할 떄 사용하는 연산자. 주어진 객체가 클래스 상속 계통에 속한 특정 타입인지 아닌지 결정.(런타임 비용이 높다)
    3. reinterpret_cast<T>(표현식) : 하부 수준 캐스팅을 위해 만드어진 연산자. ( 포인터 -> int 등..)
    4. static_cast<T>(표현식) : 암시적 변환을 강제로 진행할 때 사용. (double -> int, void* -> 일반 포인터, 기본 클래스 포인터 -> 파생 클래스 포인터 등...)
  
  - 캐스팅시 *this의 기본 클래스 부분에 대한 사본이 임시적으로 만들어진다. 함수 안에서 호출한 *this가 같은객체가 아닐 수 있다.
```cpp
  class TEST : public Parent
  {
    public:
      virtual void func1() {
        static_cast<Parent>(*this).func1();   // *this가 캐스팅 되면서 사본이 된다. 다른 객체의 func1() 호출.
      }
  }
```
  
## 28. 내부에서 사용하는 객체에 대한 "핸들"을 반환하는 코드는 되도록 피하자
  
  - 데이터 멤버가 private라도 그 멤버의 참조자를 반환하는 함수가 public이면 멤버 캡슐화 정도도 public이 된다.(포인터도 마찬가지)
  - const 참조자를 반환해도 됨.
  - 참조자 반환시 임시객체의 참조자를 반환해 무효참조하는 거 조심하자.
  
## 29. 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!
## 30. 인라인 함수는 미주알고주알 따져서 이해해 두자
## 31. 파일 사이의 컴파일 의존성을 최대로 줄이자
