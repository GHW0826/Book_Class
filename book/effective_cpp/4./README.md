
## 18. 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자
  - 제약을 넣어 잘못사용하기 어려운 방식으로 사용의 경우도 있다.
```cpp
  class Date
  {
    public:
      Date(int month, int day, int year);   // 그냥 숫자를 넣으면 되서, 순서 잘못넣거나, 범위 오류 생길수 있다.
  }
  
  class Date
  {
    public:
      Date(const Month& m, const Day& day, const Year& y);  // 래퍼타입을 만들어서 넘겨 오류를 줄이도록 함.
  }

```
  - 위 래퍼 타입을 사용시, 미리 유효한 집할을 static으로 만들어 준비해서 사용해도 됨.
```cpp
  class Month
  {
    static Month Jan() { return Month(1); }
    static Month Feb() { return Month(2); }
    ...
  }
```
  - shard_ptr은 사용자 정의 삭제자를 지원해 교차 DLL 문제, 뮤텍스등을 자동으로 잠금 해제하는데 쓸 수 있다.
```
  - 교차 DLL 문제
     객체 생성 시에 동적 링크 라이브러리의 new를 썻는데, 그 객체를 삭제할 떄는 이전의 DLL과 다른 DLL에 있는 delete를 썻을 경우 발생.
     (new, delete 짝이 실행되는 DLL이 달라서 꼬이게 된다.)
```

## 19. 클래스 설계는 타입 설계와 똑같이 취급하자

  - 클래스 설계는 기본적으로 새로운 타입 하나 정의하는 것과 같다.
  - 새 클래스 설계시 다음과 같은 사항 고려해 보자.
```
  - 새로 정의한 타입의 객체 생성 및 소멸 관리
  - 객체 초기화는 객체 대입과 어떻게 달라야 되는가
  - 새로운 타입으로 만든 개체가 값에 의해 전달되는 경우 어떤 의미를 줄것 인가
  - 새로운 타입이 가질수 있는 적법한 값에 대한 제약은?
  - 기존 클래스 상속 계통망에 맞출것?
  - 어떤 종류의 타입 변환을 허용할 것인가
  - 어떤 연산자와 함수를 두어야 의미가 있을까?
  - 표준 함수들 중 어떤 것을 허용하지 말 것인가?
  - 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?
  - 선언되지 않은 인터페이스로 무엇을 둘 것인가?
  - 새로 만드는 타입이 얼마나 일반적인가?
  - 정말로 필요한가?
```

## 20. '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다
  
  - 기본적으로 C++는 함수로부터 객체를 전달받거나 할때 값에의한 전달을 사용. (복사해서 사본을 전달, 받는다.)
  - 복사하면, 해당 클래스 관련 복사생성자, 생성자, 소멸자가 모두 호출됨. 효율이 안좋음.
  - 함수 파라미터를 (const T&) 로 받으면 참조로 받게되 위와같은 비용이 안 일어난다.
  - 파생 클래스 객체가 기본 클래스 객체로 전달되는 경우 나타나는 슬라이싱 문제도 없어짐.
  - int 같은 기본타입은 값전달이 효율적일 때가 많다.


## 21. 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

## 22. 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

## 23. 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

## 24. 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자

## 25. 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

