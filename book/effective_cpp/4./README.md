
## 18. 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자
  - 제약을 넣어 잘못사용하기 어려운 방식으로 사용의 경우도 있다.
```cpp
  class Date
  {
    public:
      Date(int month, int day, int year);   // 그냥 숫자를 넣으면 되서, 순서 잘못넣거나, 범위 오류 생길수 있다.
  }
  
  class Date
  {
    public:
      Date(const Month& m, const Day& day, const Year& y);  // 래퍼타입을 만들어서 넘겨 오류를 줄이도록 함.
  }

```
  - 위 래퍼 타입을 사용시, 미리 유효한 집할을 static으로 만들어 준비해서 사용해도 됨.
```cpp
  class Month
  {
    static Month Jan() { return Month(1); }
    static Month Feb() { return Month(2); }
    ...
  }
```
  - shard_ptr은 사용자 정의 삭제자를 지원해 교차 DLL 문제, 뮤텍스등을 자동으로 잠금 해제하는데 쓸 수 있다.
```
  - 교차 DLL 문제
     객체 생성 시에 동적 링크 라이브러리의 new를 썻는데, 그 객체를 삭제할 떄는 이전의 DLL과 다른 DLL에 있는 delete를 썻을 경우 발생.
     (new, delete 짝이 실행되는 DLL이 달라서 꼬이게 된다.)
```

## 19. 클래스 설계는 타입 설계와 똑같이 취급하자


## 20. '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다
  
## 21. 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

## 22. 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

## 23. 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

## 24. 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자

## 25. 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

