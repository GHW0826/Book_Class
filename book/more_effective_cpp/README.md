

# [More Effective C++](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788980545032&orderClick=LAG&Kc=)

### [목차]

## [Chpater 1 기본 개념들](./1.)
  1. 포인터(pointer)와 참조자(reference)를 구분하자
  2. 가능한 C++ 스타일의 캐스트를 즐겨 쓰자
  3. 배열과 다형성은 같은 수준으로 놓고 볼 것이 아니다
  4. 쓸데 없는 기본 생성자는 그냥 두지 말자

Chpater 2 연산자(Operators)
항목 5 : 사용자 정의 타입변환 함수에 대한 주의를 놓지 말자
항목 6 : 증가 및 감소 연산자의 전위(prefix)/후위(postfix) 형태를 반드시 구분하자
항목 7 : &&, ||, 혹은 . 연산자는 오버로딩 대상이 절대로 아니다
항목 8 : new와 delete의 의미를 정확히 구분하고 이해하자

Chpater 3 예외(Exceptions)
항목 9 : 리소스 누수를 피하는 방법의 정공(正攻)은 소멸자이다
항목 10 : 생성자에서는 리소스 누수가 일어나지 않게 하자
항목 11 : 소멸자에서는 예외가 탈출하지 못하게 하자
항목 12 : 예외 발생이 매개변수 전달 혹은 가상 함수 호출과 어떻게 다른지를 이해하자
항목 13 : 발생한 예외는 참조자로 받아내자
항목 14 : 예외 지정(exception specification) 기능은 냉철하게 사용하자
항목 15 : 예외 처리에 드는 비용에 대해 정확히 파악하자

Chpater 4 효율(Efficiency)
항목 16 : 뼛속까지 잊지 말자, 80-20 법칙!
항목 17 : 효율 향상에 있어 지연 평가(lazy evaluation)는 충분히 고려해 볼 만하다
항목 18 : 예상되는 계산 결과를 미리 준비하면 처리비용을 깎을 수 있다
항목 19 : 임시 객체의 원류(原流)를 정확히 이해하자
항목 20 : 반환값 최적화(return value optimization)가 가능하게 하자
항목 21 : 오버로딩은 불필요한 암시적 타입변환을 막는 한 방법이다
항목 22 : 단독 연산자(op) 대신에 =이 붙은 연산자(op=)를 사용하는 것이 좋을 때가 있다
항목 23 : 정 안 되면 다른 라이브러리를 사용하자!
항목 24 : 가상 함수, 다중 상속, 가상 기본 클래스, RTTI에 들어가는 비용을 제대로 파악하자

Chpater 5 유용하고 재미있는 프로그래밍 기법들(Techniques)
항목 25 : 생성자 함수와 비(非)멤버 함수를 가상 함수처럼 만드는 방법
항목 26 : 클래스 인스턴스의 개수를 의도대로 제한하는 방법
항목 27 : 힙(heap)에만 생성되거나 힙에는 만들어지지 않는 특수한 클래스를 만드는 방법
항목 28 : 스마트 포인터(Smart Pointer)
항목 29 : 참조 카운팅(Reference Counting)
항목 30 : 프록시(Proxy) 클래스
항목 31 : 함수를 두 개 이상의 객체(타입)에 대해 가상 함수처럼 동작하도록 만들기

Chpater 6 이외의 이야기들(Miscellany)
항목 32 : 미래 지향적인 프로그래머가 되자
항목 33 : 상속 관계의 말단에 있지 않은 (non-leaf) 클래스는 반드시 추상 클래스로 만들자
항목 34 : 한 프로그램에서 C++와 C를 함께 사용하는 방법을 이해하자
항목 35 : C++ 언어의 최신 표준안과 표준 라이브러리에 대해 익숙해지자

추천하는 읽을거리
auto_ptr 클래스 템플릿의 구현
찾아보기
