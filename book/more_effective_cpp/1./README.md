## 1. 포인터(pointer)와 참조자(reference)를 구분하자

  - 참조자 개념에선 널 참조자가 없다. 메모리 공간을 차지한 객체를 참조해야 한다.
```cpp
  // 컴파일되지만 에러발생.
  obj* pObj = nullptr;
  obj& cObj = *pObj;
```
  - 참조자는 널 값을 가질 수 없어 유효성 검사할 필요가 없다.
  - 참조자는 초기화될 때 참조했던 그 객체만 참조한다.
```
   참조자 사용해야 할때
    1. 참조할 포인터가 처음부터 끝까지 존재할 것을 알 때.
    2. 참조하는 대상 객체를 바꿀 필요가 없을 때.
    3. 포인터를 사용하면 문법상 의미가 어색할 때.
```

## 2. 가능한 C++ 스타일의 캐스트를 즐겨 쓰자

  - static_cast       : 일반적인 캐스팅
  - const_cast        : 객체의 상수성을 떼어줌.
  - dynamic_cast      : 상속 계층 관계를 가로지르거나 하향시킨 클래스 타입으로 안전하게 캐스팅할 때 사용. 부모 클래스 포인터 -> 파생 클래스 포인터(참조자도 가능). 실패시 널이나 예외.
  - reinterpret_cast  : 임의의 타입으로 캐스팅 가능.
 
## 3. 배열과 다형성은 같은 수준으로 놓고 볼 것이 아니다

  - 상속성이 주는 이득 기본 클래스 객체의 포인터나 참조자를 통해 파생 클래스 객체를 조작 가능.
  - 더해서 파생 클래스 객체의 배열을 기본 클래스 포인터, 참조자로 조작 가능.
  - 배열은 배열의 첫 요소를 가리키는 포인터 -> * (array + i). i * sizeof(배열내 요소 객체 하나).  삭제, 작업등.. 결과 미지수 조심하자.
```cpp
  class BArray
  { ... };
  class DArray : public BArray
  { ... };
  
  void printArr(const BArray arr[], int size)
  {
    for (int i = 0; i < size; ++i)
      cout << arr[i];   //  -> *(arr + i);
  }
  
  {
    BArray* B = new BArray[50];
    DArray* D = new DArray[50];
    
    printArr(B, 50);
    printArr(D, 50);  // ?
  }
```
  
## 4. 쓸데 없는 기본 생성자는 그냥 두지 말자


  
  
  
  
