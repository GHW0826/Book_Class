## 1. 포인터(pointer)와 참조자(reference)를 구분하자

  - 참조자 개념에선 널 참조자가 없다. 메모리 공간을 차지한 객체를 참조해야 한다.
```cpp
  // 컴파일되지만 에러발생.
  obj* pObj = nullptr;
  obj& cObj = *pObj;
```
  - 참조자는 널 값을 가질 수 없어 유효성 검사할 필요가 없다.
  - 참조자는 초기화될 때 참조했던 그 객체만 참조한다.
```
   참조자 사용해야 할때
    1. 참조할 포인터가 처음부터 끝까지 존재할 것을 알 때.
    2. 참조하는 대상 객체를 바꿀 필요가 없을 때.
    3. 포인터를 사용하면 문법상 의미가 어색할 때.
```

## 2. 가능한 C++ 스타일의 캐스트를 즐겨 쓰자

  - static_cast       : 일반적인 캐스팅
  - const_cast        : 객체의 상수성을 떼어줌.
  - dynamic_cast      : 상속 계층 관계를 가로지르거나 하향시킨 클래스 타입으로 안전하게 캐스팅할 때 사용. 부모 클래스 포인터 -> 파생 클래스 포인터(참조자도 가능). 실패시 널이나 예외.
  - reinterpret_cast  : 임의의 타입으로 캐스팅 가능.
 
## 3. 배열과 다형성은 같은 수준으로 놓고 볼 것이 아니다

  - 상속성이 주는 이득 기본 클래스 객체의 포인터나 참조자를 통해 파생 클래스 객체를 조작 가능.
  - 더해서 파생 클래스 객체의 배열을 기본 클래스 포인터, 참조자로 조작 가능.
  - 배열은 배열의 첫 요소를 가리키는 포인터 -> * (array + i). i * sizeof(배열내 요소 객체 하나).  삭제, 작업등.. 결과 미지수 조심하자.
```cpp
  class BArray
  { ... };
  class DArray : public BArray
  { ... };
  
  void printArr(const BArray arr[], int size)
  {
    for (int i = 0; i < size; ++i)
      cout << arr[i];   //  -> *(arr + i);
  }
  
  {
    BArray* B = new BArray[50];
    DArray* D = new DArray[50];
    
    printArr(B, 50);
    printArr(D, 50);  // ?
  }
```
  
## 4. 쓸데 없는 기본 생성자는 그냥 두지 말자

  - 기본 생성자가 없는 클래스의 동적 할당은 매개변수 지정 안됨.
```
  1. 지정된 위치에 매겨변수를 직접 넣어준다. (힙에 생성시 이 방법 안됨)
  2. 객체 배열 대신 포인터의 배열을 사용.
    배열 내의 모든 포인터가 가리키는 객체를 삭제해야 한다.
    메모리 사용량이 늘어남(포인터를 담을 공간이 필요함) ->비가공 메모리 할당후 메모리 지정.
```
```cpp
  // 1.
  class TEST
  {
    public:
      TEST(int p);
  }
  {
    TEST arr[] = { TEST(1), TEST(2), ... };   
  }
  
  // 2.
  typdef TEST* PTP;
  PTP pArr[10];
  PTP* pArr = new PTP[10];
  
  for (int i = 0; i < 10; ++i)
    pArr[i] = new TEST(i);
```

  - 기본 생성자가 없는 가상 기본 클래스는 생성자 매개변수를 파생 클래스쪽에서 제공해야하기 떄문에 쓰기 힘들다.
  - 매개변수 생성자에 기본값을 둘 수도 있지만, 기본값이 생겨 오류를 잡아내지 못할 수도 있다. (기본값 유효성)
